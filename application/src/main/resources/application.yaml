spring:
    # Maven-Spring Profilo attivo
    profiles.active: @activeProfile@

    # Output colorato
    output.ansi.enabled: always

    # Cache busting per risorse statiche
    resources.chain.strategy.content:
        enabled: true
        paths: /**

    # Resource Bundle settings
    messages:
        cache-seconds: -1
        encoding: UTF-8

    # JPA settings
    jpa:
        # Jpa nelle view disattivato
        open-in-view: false
        properties:
            hibernate:
                #dialect: org.hibernate.dialect.MySQL5Dialect
                current_session_context_class: org.springframework.orm.hibernate5.SpringSessionContext
                # Workaround. Vedi:
                # https://github.com/pgjdbc/pgjdbc/issues/1102
                # https://hibernate.atlassian.net/browse/HHH-12368
                jdbc.lob.non_contextual_creation: true

        hibernate:
            # Configurazione creazione tabelle Hibernate
            #create, update
            ddl-auto: update
            naming.physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

    # Database PostgreSQL
    datasource:
        url: jdbc:postgresql://${POSTGRES_HOST:localhost}/tek
        driverClassName: org.postgresql.Driver
        username: ${POSTGRES_USER:tek}
        password: ${POSTGRES_PASSWORD:tek}
    #        url: jdbc:mysql://${MYSQL_HOST:localhost}/tek
    #            driverClassName: com.mysql.cj.jdbc.Driver
    #            username: ${MYSQL_USER:root}
    #            password: ${MYSQL_ROOT_PASSWORD:tek}

    # Schema
    jpa.properties.hibernate.default_schema: tek

    # SMTP
    # Controllare accesso app non sicure a gmail e blocco antivirus in caso di certificato non riconosciuto a runtime
    mail:
        host: smtp.gmail.com
        port: 587
        username: marcopag90@gmail.com
        password: Thohs1qu9094
        properties.mail.smtp:
            auth: true
            connectiontimeout: 5000
            timeout: 5000
            writetimeout: 5000
            starttls.enable: true

javers:
    sqlSchema: audit

logging:
    level:
        root: INFO
        com.tek: DEBUG
        org.hibernate:
            tool.hbm2ddl: DEBUG
            SQL: DEBUG
            type: INFO #TRACE
            type.EnumType: INFO
            type.BasicTypeRegistry: INFO
            descriptor:
                sql: DEBUG
                sql.BasicExtractor: DEBUG

security:
    # basic, oauth2
    type: oauth2
    # Workaround. Vedi:
    # https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/
    # 2.7.2 Changing the Filter Order
    oauth2:
        resource.filter-order: 3
        # Authorization Server (potrebbe essere separato logicamente dal ResourceServer)
        # Default: http://localhost:8080
        accessTokenHost: http://localhost:8080

        # ClientDetailsProperties
        client:
            clientId: tekVetrina01
            clientSecret: Ygsethoh90*
            resourceId: tekVetrinaShowcase
            authority: ROLE_CLIENT
            grants: password,refresh_token,client_credentials
            scope: read,write
            accessTokenValidity: 1800
            refreshTokenValidity: 3600

    # Cors Configuration
    cors:
        # Non si puo' utilizzare la wildcard * altrimenti la request withCredentials a true non rispetta le CORS Policy
        # Inoltre, per CORS Policy non e' possibile inviare come header di risposta piu' di una origine (a meno della *)
        allowedOrigin: http://localhost:4200
        allowedCredentials: true
        # Rest Methods
        # OPTIONS : necessaria per OAuth2
        allowedMethods: GET, POST, PATCH, PUT, DELETE, OPTIONS
        # Headers
        allowedHeaders: x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN



